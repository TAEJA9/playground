import React, { useEffect, useMemo, useRef, useState } from "react"; import { motion, AnimatePresence } from "framer-motion"; import { Play, Pause, RotateCcw, Bell, BellOff, Sun, Moon, Settings2, Volume2, VolumeX, Coffee, BookOpenCheck, TimerReset } from "lucide-react"; import { Button } from "@/components/ui/button"; import { Card, CardContent, CardFooter, CardHeader, CardTitle } from "@/components/ui/card"; import { Slider } from "@/components/ui/slider"; import { Switch } from "@/components/ui/switch"; import { Input } from "@/components/ui/input";

// Base64 beep (440Hz + 660Hz quick chirp) const BEEP = "data:audio/wav;base64,UklGRqQAAABXQVZFZm10IBAAAAABAAEAESsAACJWAAACABAAZGF0YQwAAACAgICAf39/f4CAgICAf39/f4CAgICAf39/f4CAgICAf39/f4CAgICAf39/f4CAgICAf39/f4CAgICAf39/f4CAgICAf39/f4CAgID///8=";

const prettyTime = (secs: number) => { const m = Math.floor(secs / 60) .toString() .padStart(2, "0"); const s = Math.floor(secs % 60) .toString() .padStart(2, "0"); return ${m}:${s}; };

const clamp = (n: number, min: number, max: number) => Math.min(Math.max(n, min), max);

const useLocal = <T,>(key: string, initial: T) => { const [state, setState] = useState<T>(() => { try { const v = localStorage.getItem(key); return v ? (JSON.parse(v) as T) : initial; } catch { return initial; } }); useEffect(() => { try { localStorage.setItem(key, JSON.stringify(state)); } catch {} }, [key, state]); return [state, setState] as const; };

const Ring = ({ progress, size = 260 }: { progress: number; size?: number }) => { const stroke = 14; const r = (size - stroke) / 2; const c = 2 * Math.PI * r; const dash = c * progress; return ( <svg width={size} height={size} className="drop-shadow-md"> <defs> <linearGradient id="grad" x1="0%" y1="0%" x2="100%" y2="0%"> <stop offset="0%" stopColor="hsl(var(--primary))" /> <stop offset="100%" stopColor="hsl(var(--primary) / 0.6)" /> </linearGradient> </defs> <circle cx={size / 2} cy={size / 2} r={r} stroke="hsl(var(--muted))" strokeWidth={stroke} fill="none" /> <motion.circle cx={size / 2} cy={size / 2} r={r} stroke="url(#grad)" strokeLinecap="round" strokeWidth={stroke} fill="none" initial={{ strokeDasharray: ${0} ${c} }} animate={{ strokeDasharray: ${dash} ${c - dash} }} transition={{ type: "spring", stiffness: 80, damping: 20 }} /> </svg> ); };

const ModePill = ({ active, icon: Icon, label, onClick }: any) => ( <Button variant={active ? "default" : "outline"} size="sm" className="rounded-full" onClick={onClick}> <Icon className="mr-2 h-4 w-4" /> {label} </Button> );

export default function StudyTimer() { // Modes: focus / short / long const [mode, setMode] = useLocal("timer.mode", "focus"); const [focusMin, setFocusMin] = useLocal<number>("timer.focus", 50); const [shortMin, setShortMin] = useLocal<number>("timer.short", 10); const [longMin, setLongMin] = useLocal<number>("timer.long", 20); const [longGap, setLongGap] = useLocal<number>("timer.longgap", 4); // after N focus blocks const [autoNext, setAutoNext] = useLocal<boolean>("timer.autonext", true); const [soundOn, setSoundOn] = useLocal<boolean>("timer.sound", true); const [notiOn, setNotiOn] = useLocal<boolean>("timer.noti", true); const [dark, setDark] = useLocal<boolean>("timer.dark", true);

const totalSecs = useMemo(() => { const m = mode === "focus" ? focusMin : mode === "short" ? shortMin : longMin; return m * 60; }, [mode, focusMin, shortMin, longMin]);

const [remaining, setRemaining] = useLocal<number>("timer.remaining", totalSecs); const [running, setRunning] = useLocal<boolean>("timer.running", false); const [focusCount, setFocusCount] = useLocal<number>("timer.focuscount", 0);

const audioRef = useRef<HTMLAudioElement | null>(null);

// sync remaining when mode durations change useEffect(() => { setRemaining((r) => (r > totalSecs ? totalSecs : r)); }, [totalSecs, setRemaining]);

// tick useEffect(() => { if (!running) return; const id = setInterval(() => { setRemaining((r) => { if (r <= 1) { return 0; } return r - 1; }); }, 1000); return () => clearInterval(id); }, [running, setRemaining]);

// finish handler useEffect(() => { if (remaining === 0) { if (soundOn && audioRef.current) { audioRef.current.currentTime = 0; audioRef.current.play().catch(() => {}); } if (notiOn && "Notification" in window) { if (Notification.permission === "granted") { new Notification("타이머 완료!", { body: mode === "focus" ? "집중 세션 종료, 휴식 가시죠." : "휴식 종료, 다시 집중 GO!" }); } }

// Auto-switch
  let nextMode = mode;
  if (mode === "focus") {
    const nextFocusCount = focusCount + 1;
    setFocusCount(nextFocusCount);
    nextMode = nextFocusCount % longGap === 0 ? "long" : "short";
  } else {
    nextMode = "focus";
  }

  if (autoNext) {
    // set a tiny delay so user sees 00:00
    setTimeout(() => {
      switchMode(nextMode, true);
    }, 600);
  } else {
    setRunning(false);
  }
}
// eslint-disable-next-line react-hooks/exhaustive-deps

}, [remaining]);

// desktop notification permission on mount useEffect(() => { if (notiOn && "Notification" in window && Notification.permission === "default") { Notification.requestPermission().catch(() => {}); } }, [notiOn]);

const switchMode = (m: "focus" | "short" | "long", autostart = false) => { setMode(m); const secs = (m === "focus" ? focusMin : m === "short" ? shortMin : longMin) * 60; setRemaining(secs); setRunning(autostart); };

const progress = 1 - remaining / totalSecs;

// keyboard shortcuts useEffect(() => { const onKey = (e: KeyboardEvent) => { if (e.code === "Space") { e.preventDefault(); setRunning((v) => !v); } else if (e.key.toLowerCase() === "r") { reset(); } }; window.addEventListener("keydown", onKey); return () => window.removeEventListener("keydown", onKey); }, []);

const reset = () => { setRemaining(totalSecs); setRunning(false); };

useEffect(() => { document.documentElement.classList.toggle("dark", dark); }, [dark]);

return ( <div className="min-h-screen bg-background text-foreground transition-colors"> <div className="mx-auto max-w-5xl px-4 py-8"> <div className="mb-6 flex items-center justify-between"> <div> <h1 className="text-2xl font-bold">Morning Study Timer</h1> <p className="text-muted-foreground">집중-휴식 리듬을 예쁘게. 스페이스바로 시작/일시정지, R로 리셋.</p> </div> <div className="flex items-center gap-2"> <Button variant="ghost" size="icon" onClick={() => setDark((v) => !v)} aria-label="toggle theme"> {dark ? <Sun className="h-5 w-5" /> : <Moon className="h-5 w-5" />} </Button> <Button variant="ghost" size="icon" onClick={() => setSoundOn((v) => !v)} aria-label="toggle sound"> {soundOn ? <Volume2 className="h-5 w-5" /> : <VolumeX className="h-5 w-5" />} </Button> <Button variant="ghost" size="icon" onClick={() => setNotiOn((v) => !v)} aria-label="toggle notifications"> {notiOn ? <Bell className="h-5 w-5" /> : <BellOff className="h-5 w-5" />} </Button> </div> </div>

<div className="grid grid-cols-1 gap-6 lg:grid-cols-3">
      {/* Timer Card */}
      <Card className="lg:col-span-2">
        <CardHeader className="pb-2">
          <div className="flex flex-wrap gap-2">
            <ModePill active={mode === "focus"} icon={BookOpenCheck} label="집중" onClick={() => switchMode("focus")} />
            <ModePill active={mode === "short"} icon={Coffee} label="짧은 휴식" onClick={() => switchMode("short")} />
            <ModePill active={mode === "long"} icon={TimerReset} label="긴 휴식" onClick={() => switchMode("long")} />
          </div>
        </CardHeader>
        <CardContent>
          <div className="flex flex-col items-center justify-center gap-6 p-2">
            <div className="relative">
              <Ring progress={progress} />
              <div className="absolute inset-0 flex flex-col items-center justify-center">
                <AnimatePresence mode="wait">
                  <motion.div key={remaining} initial={{ opacity: 0, y: 6 }} animate={{ opacity: 1, y: 0 }} exit={{ opacity: 0, y: -6 }} className="text-6xl font-bold tabular-nums">
                    {prettyTime(remaining)}
                  </motion.div>
                </AnimatePresence>
                <div className="mt-2 text-sm text-muted-foreground">
                  {mode === "focus" ? "집중 시간" : mode === "short" ? "짧은 휴식" : "긴 휴식"}
                </div>
              </div>
            </div>
            <div className="flex gap-2">
              <Button size="lg" onClick={() => setRunning((v) => !v)}>
                {running ? (
                  <>
                    <Pause className="mr-2 h-5 w-5" /> 일시정지
                  </>
                ) : (
                  <>
                    <Play className="mr-2 h-5 w-5" /> 시작
                  </>
                )}
              </Button>
              <Button size="lg" variant="outline" onClick={reset}>
                <RotateCcw className="mr-2 h-5 w-5" /> 리셋
              </Button>
            </div>
          </div>
        </CardContent>
        <CardFooter className="justify-center">
          <div className="flex flex-wrap items-center justify-center gap-2 text-sm">
            <span className="text-muted-foreground">프리셋:</span>
            <Button variant="secondary" size="sm" onClick={() => { setFocusMin(25); setShortMin(5); setLongMin(15); setLongGap(4); switchMode("focus"); }}>25/5(15)</Button>
            <Button variant="secondary" size="sm" onClick={() => { setFocusMin(50); setShortMin(10); setLongMin(20); setLongGap(3); switchMode("focus"); }}>50/10(20)</Button>
            <Button variant="secondary" size="sm" onClick={() => { setFocusMin(90); setShortMin(15); setLongMin(25); setLongGap(2); switchMode("focus"); }}>90/15(25)</Button>
          </div>
        </CardFooter>
      </Card>

      {/* Settings Card */}
      <Card>
        <CardHeader>
          <CardTitle className="flex items-center gap-2"><Settings2 className="h-5 w-5" /> 설정</CardTitle>
        </CardHeader>
        <CardContent className="space-y-6">
          <div>
            <div className="mb-2 flex items-center justify-between">
              <label className="text-sm text-muted-foreground">집중 (분)</label>
              <Input type="number" className="w-24" min={5} max={240} value={focusMin} onChange={(e) => setFocusMin(clamp(parseInt(e.target.value || "0"), 5, 240))} />
            </div>
            <Slider value={[focusMin]} min={5} max={120} step={5} onValueChange={(v) => setFocusMin(v[0])} />
          </div>
          <div>
            <div className="mb-2 flex items-center justify-between">
              <label className="text-sm text-muted-foreground">짧은 휴식 (분)</label>
              <Input type="number" className="w-24" min={1} max={60} value={shortMin} onChange={(e) => setShortMin(clamp(parseInt(e.target.value || "0"), 1, 60))} />
            </div>
            <Slider value={[shortMin]} min={1} max={30} step={1} onValueChange={(v) => setShortMin(v[0])} />
          </div>
          <div>
            <div className="mb-2 flex items-center justify-between">
              <label className="text-sm text-muted-foreground">긴 휴식 (분)</label>
              <Input type="number" className="w-24" min={5} max={120} value={longMin} onChange={(e) => setLongMin(clamp(parseInt(e.target.value || "0"), 5, 120))} />
            </div>
            <Slider value={[longMin]} min={5} max={60} step={5} onValueChange={(v) => setLongMin(v[0])} />
          </div>
          <div>
            <div className="mb-2 flex items-center justify-between">
              <label className="text-sm text-muted-foreground">긴 휴식 주기 (집중 N회마다)</label>
              <Input type="number" className="w-24" min={2} max={10} value={longGap} onChange={(e) => setLongGap(clamp(parseInt(e.target.value || "0"), 2, 10))} />
            </div>
            <Slider value={[longGap]} min={2} max={8} step={1} onValueChange={(v) => setLongGap(v[0])} />
          </div>
          <div className="flex items-center justify-between">
            <div>
              <div className="text-sm font-medium">자동 다음 세션</div>
              <div className="text-xs text-muted-foreground">끝나면 다음 모드로 자동 전환</div>
            </div>
            <Switch checked={autoNext} onCheckedChange={setAutoNext} />
          </div>
        </CardContent>
      </Card>
    </div>

    <p className="mt-8 text-center text-xs text-muted-foreground">
      ⌨️ 스페이스바: 시작/일시정지 • R: 리셋 • 로컬 저장으로 설정 유지 • 데스크톱 알림 사용 가능
    </p>
  </div>

  <audio ref={audioRef} src={BEEP} preload="auto" />

  {/* Theme container */}
  <style>{`
    :root { color-scheme: light; }
    .dark { color-scheme: dark; }
  `}</style>
</div>

); }